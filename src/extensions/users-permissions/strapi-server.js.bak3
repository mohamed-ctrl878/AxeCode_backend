'use strict';

const _ = require('lodash');
const { yup, validateYupSchema } = require('@strapi/utils');
const { ValidationError, ApplicationError } = require('@strapi/utils').errors;

const emailRegExp = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

module.exports = (plugin) => {
  // Validation schema for registration
  const validateRegistrationData = async (data) => {
    const schema = yup.object().shape({
      email: yup.string().email().required(),
      password: yup.string().min(6).required(),
      username: yup.string(),
      firstname: yup.string(),
      lastname: yup.string(),
      phone: yup.string().min(8),
      birthday: yup.date().max(new Date(), 'Birthday cannot be in the future')
    });

    try {
      await validateYupSchema(schema)(data);
    } catch (error) {
      throw new ValidationError(error.message);
    }
  };

  const sanitizeUser = (user) => {
    const { password, resetPasswordToken, confirmationToken, ...sanitizedUser } = user;
    return sanitizedUser;
  };

  plugin.controllers.auth.register = async (ctx) => {
    try {
      const pluginStore = strapi.store({ type: 'plugin', name: 'users-permissions' });
      const settings = await pluginStore.get({ key: 'advanced' });

      if (settings && !settings.allow_register) {
        throw new ApplicationError('Register action is currently disabled');
      }

      // Validate input data
      await validateRegistrationData(ctx.request.body);

      const params = {
        ...ctx.request.body,
        provider: 'local',
      };

      // Get default role
      const role = await strapi
        .query('plugin::users-permissions.role')
        .findOne({ 
          where: { 
            type: settings && settings.default_role ? settings.default_role : 'authenticated'
          } 
        });

      if (!role) {
        throw new ApplicationError('Impossible to find the default role');
      }

      // Check for existing user
      const existingUser = await strapi
        .query('plugin::users-permissions.user')
        .findOne({ where: { email: params.email.toLowerCase() } });

      if (existingUser) {
        throw new ApplicationError('Email is already taken');
      }

      try {
        params.role = role.id;
        params.email = params.email.toLowerCase();
        params.username = params.username || params.email;
        params.confirmed = !settings?.email_confirmation;

        const user = await strapi.query('plugin::users-permissions.user').create({ data: params });
        const sanitizedUser = sanitizeUser(user);

        if (settings?.email_confirmation) {
          try {
            await strapi
              .plugin('users-permissions')
              .service('user')
              .sendConfirmationEmail(sanitizedUser);
          } catch (err) {
            throw new ApplicationError('Error sending confirmation email');
          }

          return ctx.send({ user: sanitizedUser });
        }

        const jwt = strapi
          .plugin('users-permissions')
          .service('jwt')
          .issue(_.pick(user, ['id']));

        return ctx.send({
          jwt,
          user: sanitizedUser,
        });
      } catch (err) {
        strapi.log.error(err);
        if (_.includes(err.message, 'username')) {
          throw new ApplicationError('Username already taken');
        } else {
          throw new ApplicationError('An error occurred during account creation');
        }
      }
    } catch (err) {
      if (err.name === 'ValidationError') {
        throw new ValidationError(err.message);
      }
      throw err;
    }
  };

  return plugin;
};
const registerSchema = yup.object().shape({
  email: yup.string().email().required(),
  password: yup.string().min(6).required(),
  username: yup.string(),
  firstname: yup.string(),
  lastname: yup.string(),
  phone: yup.string().min(8),
  birthday: yup.date().max(new Date(), 'Birthday cannot be in the future')
});

module.exports = (plugin) => {
  const sanitizeUser = (user) => {
    const { password, resetPasswordToken, confirmationToken, ...sanitizedUser } = user;
    return sanitizedUser;
  };

  // Override the register controller with improved error handling
  plugin.controllers.auth.register = async (ctx) => {
    try {
      // Log registration attempt
      strapi.log.info('Registration attempt received:', { email: ctx.request.body.email });
      
      // Validate request body against schema
      await validateYupSchema(registerSchema)(ctx.request.body);
      
      const pluginStore = strapi.store({ type: 'plugin', name: 'users-permissions' });
      const settings = await pluginStore.get({ key: 'advanced' });

      if (!settings?.allow_register) {
        throw new ApplicationError('Register action is currently disabled');
      }

      const params = {
        ...ctx.request.body,
        provider: 'local',
      };

      // Validate password
      if (params.password.split('$').length > 3) {
        throw new ValidationError('Your password cannot contain more than three times the symbol `$`');
      }

      // Get default role
      const role = await strapi
        .query('plugin::users-permissions.role')
        .findOne({ where: { type: settings?.default_role || 'authenticated' } });

      if (!role) {
        throw new ApplicationError('Impossible to find the default role');
      }

      // Email validation
      if (!emailRegExp.test(params.email)) {
        throw new ValidationError('Please provide a valid email address');
      }
      params.email = params.email.toLowerCase();

      // Check for existing user
      const existingUser = await strapi
        .query('plugin::users-permissions.user')
        .findOne({ where: { email: params.email } });

      if (existingUser) {
        throw new ApplicationError('Email is already taken');
      }

      try {
        // Create the user
        const user = await getService('user').add({
          ...params,
          role: role.id,
          email: params.email,
          username: params.username || params.email,
          confirmed: !settings?.email_confirmation,
          birthday: params.birthday,
          phone: params.phone,
          firstname: params.firstname,
          lastname: params.lastname,
        });

        strapi.log.info('User created successfully:', { id: user.id, email: user.email });

        const sanitizedUser = sanitizeUser(user);

        if (settings?.email_confirmation) {
          try {
            await getService('auth').sendConfirmationEmail(sanitizedUser);
            strapi.log.info('Confirmation email sent:', { email: user.email });
          } catch (err) {
            strapi.log.error('Failed to send confirmation email:', err);
            throw new ApplicationError('Failed to send confirmation email');
          }

          return ctx.send({ user: sanitizedUser });
        }

        const jwt = getService('jwt').issue(_.pick(user, ['id']));
        strapi.log.info('Registration completed successfully:', { id: user.id });

        return ctx.send({
          jwt,
          user: sanitizedUser,
        });
      } catch (err) {
        strapi.log.error('Registration error:', err);
        if (_.includes(err.message, 'username')) {
          throw new ApplicationError('Username already taken');
        } else {
          throw new ApplicationError('An error occurred during account creation');
        }
      }
    } catch (err) {
      strapi.log.error('Registration validation error:', err);
      if (err.name === 'ValidationError') {
        throw new ValidationError(err.message);
      }
      throw err;
    }
  };

  return plugin;
};

const getService = name => {
  return strapi.plugin('users-permissions').service(name);
};

// Registration validation schema
const registerSchema = yup.object().shape({
  email: yup.string().email().required(),
  password: yup.string().min(6).required(),
  username: yup.string(),
  firstname: yup.string(),
  lastname: yup.string(),
  phone: yup.string().min(8),
  birthday: yup.date().max(new Date(), 'Birthday cannot be in the future')
});

module.exports = (plugin) => {
  const sanitizeUser = (user) => {
    const { password, resetPasswordToken, confirmationToken, ...sanitizedUser } = user;
    return sanitizedUser;
  };

  // Store the original register controller
  const originalRegister = plugin.controllers.auth.register;

  // Override the register controller
  plugin.controllers.auth.register = async (ctx) => {
    try {
      // Validate request body against schema
      await validateYupSchema(registerSchema)(ctx.request.body);
      
      const pluginStore = strapi.store({ type: 'plugin', name: 'users-permissions' });
      const settings = await pluginStore.get({ key: 'advanced' });

      if (!settings.allow_register) {
        throw new ApplicationError('Register action is currently disabled');
      }

      const params = {
        ...ctx.request.body,
        provider: 'local',
      };

      // Throw an error if the password selected by the user
      // contains more than three times the symbol '$'
      if (params.password.split('$').length > 3) {
        throw new ValidationError('Your password cannot contain more than three times the symbol `$`');
      }

      const role = await strapi
        .query('plugin::users-permissions.role')
        .findOne({ where: { type: settings.default_role } });

      if (!role) {
        throw new ApplicationError('Impossible to find the default role');
      }

      // Check if the provided email is valid
      const isEmail = emailRegExp.test(params.email);

      if (isEmail) {
        params.email = params.email.toLowerCase();
      } else {
        throw new ValidationError('Please provide a valid email address');
      }

      const existingUser = await strapi
        .query('plugin::users-permissions.user')
        .findOne({ where: { email: params.email } });

      if (existingUser) {
        throw new ApplicationError('Email is already taken');
      }

      try {
        const user = await getService('user').add({
          ...params,
          role: role.id,
          email: params.email,
          username: params.username || params.email,
          confirmed: !settings.email_confirmation,
          birthday: params.birthday,
          phone: params.phone,
          firstname: params.firstname,
          lastname: params.lastname,
        });

        const sanitizedUser = sanitizeUser(user);

        if (settings.email_confirmation) {
          try {
            await getService('auth').sendConfirmationEmail(sanitizedUser);
          } catch (err) {
            throw new ApplicationError(err.message);
          }

          return ctx.send({ user: sanitizedUser });
        }

        const jwt = getService('jwt').issue(_.pick(user, ['id']));

        return ctx.send({
          jwt,
          user: sanitizedUser,
        });
      } catch (err) {
        if (_.includes(err.message, 'username')) {
          throw new ApplicationError('Username already taken');
        } else {
          throw new ApplicationError('An error occurred during account creation');
        }
      }
    } catch (err) {
      if (err.name === 'ValidationError') {
        throw new ValidationError(err.message);
      }
      throw err;
    }
  };

  return plugin;
};