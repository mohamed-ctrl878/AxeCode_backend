ØªØ­Ù„ÙŠÙ„ Ø´Ø§Ù…Ù„ ÙˆØªØµÙ…ÙŠÙ… Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ© (Recommendation System Design)Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ù†Ø§Ù‚Ø´Ø§ØªÙ†Ø§ Ø§Ù„Ø¹Ù…ÙŠÙ‚Ø©ØŒ Ù‚Ù…Øª Ø¨ØªØ¬Ù…ÙŠØ¹ ÙƒÙ„ Ù‚Ø·Ø¹Ø© Ù…Ù† "Ø£Ø­Ø¬ÙŠØ©" Ø§Ù„Ù†Ø¸Ø§Ù… (Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§ØªØŒ Ù‡ÙŠØ§ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø­Ø§ÙØ©ØŒ ÙˆØ¢Ù„ÙŠØ§Øª Ø§Ù„ØªÙ†ÙˆÙŠØ¹) ÙÙŠ ÙˆØ«ÙŠÙ‚Ø© ØªØµÙ…ÙŠÙ… ÙÙ†ÙŠ ÙˆØ§Ø­Ø¯Ø© Ø´Ø§Ù…Ù„Ø©.Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ³Ù„ÙŠÙ… Ù„ÙØ±ÙŠÙ‚ Ø§Ù„ØªØ·ÙˆÙŠØ± (Backend/Data Engineers) Ù„Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ù„ØªÙ†ÙÙŠØ° ÙÙˆØ±Ø§Ù‹.Ù…Ù„Ù Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙÙ†ÙŠ (System Design Document)Markdown# ğŸ“± Feature: Content Recommendation Engine (MVP)

## 1. Overview (Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©)
**Objective:** Implement a lightweight, scalable **Content-Based Filtering** recommendation system that adapts to user behavior in real-time.
**Core Philosophy:** - **Dynamic Tagging (Folksonomy):** Tags are generated by publishers but normalized by the system.
- **Explicit & Implicit Feedback:** User interests are built from clicks, likes, and reports.
- **Noise Reduction:** Scores are normalized to prevent tag spamming.
- **Discovery:** A mix of personalized (80%) and trending/random (20%) content.

---

## 2. Data Architecture (Ù‡ÙŠÙƒÙ„Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)

### A. Content Model (Collection: `contents`)
Stores the articles/posts with their associated tags.
```json
{
  "_id": "content_123",
  "title": "Introduction to AI",
  "body_text": "...",
  "category_id": "tech_01",
  "tags": ["ai", "programming", "future_tech"], // Normalized & indexed
  "created_at": "ISODate(...)",
  "engagement_score": 150 // Global popularity counter (optional for cold start)
}
Index Strategy: Create Multikey Index (MongoDB) or GIN Index (Postgres) on 'tags' field.B. User Profile Model (Collection: users)Stores the dynamic interest map and history log.JSON{
  "_id": "user_999",
  "interest_map": {
    "ai": 12.5,
    "programming": 8.0,
    "cooking": 1.2
  },
  "seen_history": ["content_123", "content_456"], // Capped at 500 IDs
  "last_decay_date": "ISODate(...)"
}
C. Global Tags Container (Collection: global_tags)Used for Autocomplete and Tag Management.JSON{
  "_id": "tag_ai",
  "name": "ai",       // Unique, Lowercase, Trimmed
  "count": 5000,      // Usage frequency
  "last_used": "ISODate(...)"
}
Index Strategy: B-Tree Index on 'name' for Prefix Search (Autocomplete).3. Data Ingestion & Write Path (Ù…Ø³Ø§Ø± ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰)Process: Publisher Publishing ContentWhen a publisher submits content, the system processes tags before saving.Logic Flow:Input: Publisher submits text + selected tags.Normalization: * Convert to lowercase.Trim whitespace.Replace inner spaces with underscores (optional: machine learning -> machine_learning).Validation & Fallback (The "Ghost Content" Fix):IF tags array is NOT empty: Use provided tags.ELSE IF tags array is empty:Step A: Strip Stop Words (ÙÙŠ, Ù…Ù†, the, is, ...).Step B: Extract top 5 frequent words from body_text.Step C: Check if these words exist in global_tags.Step D: If still empty, inherit category_id name as a tag.Storage: Save content to DB.Global Update: Upsert tags into global_tags (increment count).4. Feedback Loop & Scoring (Ù…Ø³Ø§Ø± ØªÙØ§Ø¹Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…)A. Scoring MatrixActionScoreTypeClick+1ImplicitLike+2ExplicitClick + Like+3 (Cumulative)Strong SignalReport-5Negative SignalB. Normalization Algorithm (Prevention of Spam)To ensure user profile stability, points are distributed across content tags.$$PointsPerTag = \frac{TotalActionScore}{CountOfTags}$$Implementation:Pythondef on_user_interaction(user_id, content_tags, action):
    score = get_score(action)
    points = score / len(content_tags)
    
    user = get_user(user_id)
    
    # Update Interests
    for tag in content_tags:
        user.interest_map[tag] = user.interest_map.get(tag, 0) + points
        
    # Pruning (Maintenance)
    if len(user.interest_map) > 100:
        # Remove lowest scoring tags
        user.interest_map = keep_top_100_tags(user.interest_map)
        
    # Update History
    user.seen_history.push(content_id)
    if len(user.seen_history) > 500:
         user.seen_history.pop_first() # Remove oldest
         
    save_user(user)
5. Recommendation Retrieval Engine (Ù…Ø³Ø§Ø± Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© ÙˆØ§Ù„Ø¬Ù„Ø¨)This logic executes when the user requests their "Home Feed".Phase 1: User Context AnalysisCheck Cold Start: If interest_map is empty -> Return Get_Trending_Content().Extract Context: Get Top-N tags (e.g., top 10) sorted by score.query_tags = ["ai", "programming", "tech"]Phase 2: Candidate Generation (Filtering)Query the database for relevant content, excluding what was already seen.Query Logic (Pseudo-SQL):SQLSELECT * FROM contents 
WHERE tags IN (query_tags) 
AND _id NOT IN (user.seen_history)
LIMIT 50; -- Get 50 candidates
Phase 3: Ranking (Scoring)Calculate a relevance score for each candidate.$$RelevanceScore = \sum_{tag \in Content} (UserInterestScore_{tag})$$Phase 4: Diversity & Mixing (The 80/20 Rule)Personalized Set: Top 16 items from Phase 3.Discovery Set: 4 items from Trending or Random categories (that are NOT in seen_history).Final Feed: Shuffle (Personalized + Discovery).Phase 5: Scarcity Handling (Backfill)IF total items < 20:Fetch Latest content (excluding seen).Append to list until count == 20.6. Maintenance & Optimization (Ø§Ù„ØµÙŠØ§Ù†Ø© ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡)A. Time Decay (To prevent stagnation)Schedule: Weekly Cron Job.Logic: Multiply all user scores by a decay factor (e.g., 0.9).New_Score = Old_Score * 0.9Effect: Old interests fade away if not reinforced; new interests rise quickly.B. Autocomplete (UX)Endpoint: GET /tags/search?q=foLogic:Sanitize input (fo -> lowercase).Query global_tags: find({ name: /^fo/ }).sort({ count: -1 }).limit(5)Return list to publisher.7. Edge Cases Summary tableScenarioSystem BehaviorNew UserShow Trending/Global Popular content.New ContentContent is recommended immediately based on its tags (No waiting for views).No Tags providedAuto-tag using stop-word removal + frequency analysis OR inherit Category.Duplicate ViewsFiltered via seen_history (Cap: 500 items).Low Content VolumeBackfill with "Latest" articles to ensure full UI.
Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØºØ·ÙŠ ÙƒÙ„ Ø´ÙŠØ¡:
1.  **Ø§Ù„Ø¨Ù†ÙŠØ© (Structure):** ÙƒÙŠÙ Ù†Ø®Ø²Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.
2.  **Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (Input):** ÙƒÙŠÙ Ù†Ø¹Ø§Ù„Ø¬ Ø§Ù„ÙˆØ³ÙˆÙ… ÙˆÙ†ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ÙƒØ³Ù„ (Auto-tagging).
3.  **Ø§Ù„ØªÙØ§Ø¹Ù„ (Process):** Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø·.
4.  **Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (Output):** Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø¨Ø­Ø«ØŒ Ø§Ù„ØªØ±ØªÙŠØ¨ØŒ Ø§Ù„ØªÙ†ÙˆÙŠØ¹ØŒ ÙˆÙ…Ù„Ø¡ Ø§Ù„ÙØ±Ø§ØºØ§Øª.
5.  **Ø§Ù„ØµÙŠØ§Ù†Ø©:** Ø§Ù„ØªØ­Ù„Ù„ Ø§Ù„Ø²Ù…Ù†ÙŠ (Time Decay).

ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø³Ø® Ù‡Ø°Ø§ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆØ­ÙØ¸Ù‡ Ø¨ØµÙŠØºØ© `.md` ÙˆØªØ³Ù„ÙŠÙ…Ù‡ Ù„ÙØ±ÙŠÙ‚Ùƒ.